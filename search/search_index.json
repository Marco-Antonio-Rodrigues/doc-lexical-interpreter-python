{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Lexical Interpreter Este \u00e9 um projeto de interpreta\u00e7\u00e3o lexical para uma linguagem espec\u00edfica, desenvolvido em Python. Ele \u00e9 composto por m\u00f3dulos que realizam diferentes etapas de an\u00e1lise, como tokeniza\u00e7\u00e3o, an\u00e1lise de erros e execu\u00e7\u00e3o interativa. \ud83d\udcc1 Estrutura do Projeto LEXICAL-INTERPRETER/ \u251c\u2500\u2500 app/ # C\u00f3digo principal do interpretador \u2502 \u251c\u2500\u2500 __init__.py # Arquivo de inicializa\u00e7\u00e3o do m\u00f3dulo \u2502 \u251c\u2500\u2500 Consts.py # Constantes usadas no projeto \u2502 \u251c\u2500\u2500 Error.py # Classe de tratamento de erros \u2502 \u251c\u2500\u2500 Lexer.py # Lexer: m\u00f3dulo de an\u00e1lise lexical \u2502 \u251c\u2500\u2500 Repl.py # REPL: Loop interativo de execu\u00e7\u00e3o \u2502 \u2514\u2500\u2500 Token.py # Defini\u00e7\u00e3o e manipula\u00e7\u00e3o de tokens \u251c\u2500\u2500 tests/ # Diret\u00f3rio de testes \u251c\u2500\u2500 .gitignore # Arquivos e pastas ignorados pelo Git \u251c\u2500\u2500 Gramatica.txt # Arquivo de defini\u00e7\u00e3o da gram\u00e1tica da linguagem \u251c\u2500\u2500 main.py # Ponto de entrada do programa \u251c\u2500\u2500 poetry.lock # Arquivo de bloqueio do Poetry \u2514\u2500\u2500 pyproject.toml # Arquivo de configura\u00e7\u00e3o do Poetry \ud83d\udee0\ufe0f Funcionalidades An\u00e1lise Lexical (Lexer): Identifica e separa tokens do c\u00f3digo-fonte com base na gram\u00e1tica especificada. Tratamento de Erros (Error): Gera mensagens claras e detalhadas para erros encontrados durante a an\u00e1lise lexical. Loop Interativo (REPL): Permite que o usu\u00e1rio interaja diretamente com o interpretador em um ambiente de linha de comando. Defini\u00e7\u00e3o de Tokens (Token): Representa os diferentes tipos de tokens usados na linguagem. \ud83d\ude80 Como Executar Pr\u00e9-requisitos Python 3.8 ou superior Poetry (para gerenciamento de depend\u00eancias) Instala\u00e7\u00e3o Clone o reposit\u00f3rio: bash git clone <url_do_repositorio> cd <name_repositorio> Instale as depend\u00eancias usando o Poetry: bash poetry install Execute o programa principal: bash poetry run python main.py \ud83e\uddea Testes Para rodar os testes: Certifique-se de que as depend\u00eancias est\u00e3o instaladas. Execute os testes com: bash poetry run pytest \ud83d\udcdc Gram\u00e1tica A gram\u00e1tica da linguagem utilizada est\u00e1 definida no arquivo Gramatica.txt . Consulte este arquivo para entender as regras e estruturas reconhecidas pelo interpretador.","title":"Lexical Interpreter"},{"location":"#lexical-interpreter","text":"Este \u00e9 um projeto de interpreta\u00e7\u00e3o lexical para uma linguagem espec\u00edfica, desenvolvido em Python. Ele \u00e9 composto por m\u00f3dulos que realizam diferentes etapas de an\u00e1lise, como tokeniza\u00e7\u00e3o, an\u00e1lise de erros e execu\u00e7\u00e3o interativa.","title":"Lexical Interpreter"},{"location":"#estrutura-do-projeto","text":"LEXICAL-INTERPRETER/ \u251c\u2500\u2500 app/ # C\u00f3digo principal do interpretador \u2502 \u251c\u2500\u2500 __init__.py # Arquivo de inicializa\u00e7\u00e3o do m\u00f3dulo \u2502 \u251c\u2500\u2500 Consts.py # Constantes usadas no projeto \u2502 \u251c\u2500\u2500 Error.py # Classe de tratamento de erros \u2502 \u251c\u2500\u2500 Lexer.py # Lexer: m\u00f3dulo de an\u00e1lise lexical \u2502 \u251c\u2500\u2500 Repl.py # REPL: Loop interativo de execu\u00e7\u00e3o \u2502 \u2514\u2500\u2500 Token.py # Defini\u00e7\u00e3o e manipula\u00e7\u00e3o de tokens \u251c\u2500\u2500 tests/ # Diret\u00f3rio de testes \u251c\u2500\u2500 .gitignore # Arquivos e pastas ignorados pelo Git \u251c\u2500\u2500 Gramatica.txt # Arquivo de defini\u00e7\u00e3o da gram\u00e1tica da linguagem \u251c\u2500\u2500 main.py # Ponto de entrada do programa \u251c\u2500\u2500 poetry.lock # Arquivo de bloqueio do Poetry \u2514\u2500\u2500 pyproject.toml # Arquivo de configura\u00e7\u00e3o do Poetry","title":"\ud83d\udcc1 Estrutura do Projeto"},{"location":"#funcionalidades","text":"","title":"\ud83d\udee0\ufe0f Funcionalidades"},{"location":"#analise-lexical-lexer","text":"Identifica e separa tokens do c\u00f3digo-fonte com base na gram\u00e1tica especificada.","title":"An\u00e1lise Lexical (Lexer):"},{"location":"#tratamento-de-erros-error","text":"Gera mensagens claras e detalhadas para erros encontrados durante a an\u00e1lise lexical.","title":"Tratamento de Erros (Error):"},{"location":"#loop-interativo-repl","text":"Permite que o usu\u00e1rio interaja diretamente com o interpretador em um ambiente de linha de comando.","title":"Loop Interativo (REPL):"},{"location":"#definicao-de-tokens-token","text":"Representa os diferentes tipos de tokens usados na linguagem.","title":"Defini\u00e7\u00e3o de Tokens (Token):"},{"location":"#como-executar","text":"","title":"\ud83d\ude80 Como Executar"},{"location":"#pre-requisitos","text":"Python 3.8 ou superior Poetry (para gerenciamento de depend\u00eancias)","title":"Pr\u00e9-requisitos"},{"location":"#instalacao","text":"Clone o reposit\u00f3rio: bash git clone <url_do_repositorio> cd <name_repositorio> Instale as depend\u00eancias usando o Poetry: bash poetry install Execute o programa principal: bash poetry run python main.py","title":"Instala\u00e7\u00e3o"},{"location":"#testes","text":"Para rodar os testes: Certifique-se de que as depend\u00eancias est\u00e3o instaladas. Execute os testes com: bash poetry run pytest","title":"\ud83e\uddea Testes"},{"location":"#gramatica","text":"A gram\u00e1tica da linguagem utilizada est\u00e1 definida no arquivo Gramatica.txt . Consulte este arquivo para entender as regras e estruturas reconhecidas pelo interpretador.","title":"\ud83d\udcdc Gram\u00e1tica"},{"location":"BNF/","text":"BNF O Backus-Naur Form (BNF) \u00e9 um padr\u00e3o usado para descrever a gram\u00e1tica de linguagens de programa\u00e7\u00e3o e outras linguagens formais. Ele define a estrutura da linguagem de forma precisa e rigorosa, sendo amplamente utilizado em compiladores, interpretadores e documenta\u00e7\u00e3o t\u00e9cnica. Estrutura B\u00e1sica do BNF O BNF utiliza produ\u00e7\u00f5es para descrever regras. Cada produ\u00e7\u00e3o \u00e9 composta por: N\u00e3o Terminais : Elementos abstratos da linguagem que precisam ser definidos por outras regras. Representados entre <> (ex.: <expression> , <term> ). Terminais : Elementos literais da linguagem, como palavras-chave, n\u00fameros e operadores. Geralmente escritos como est\u00e3o. Produ\u00e7\u00f5es : Cada regra tem o formato: bnf <n\u00e3o-terminal> ::= <express\u00e3o> Usa | para indicar alternativas. Recurs\u00e3o : Permite definir estruturas aninhadas. Exemplo de Gram\u00e1tica em BNF Vamos criar a gram\u00e1tica de uma calculadora simples: <expression> ::= <term> \"+\" <term> | <term> \"-\" <term> | <term> <term> ::= <factor> \"*\" <factor> | <factor> \"/\" <factor> | <factor> <factor> ::= <number> | \"(\" <expression> \")\" <number> ::= \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\" Elementos do BNF Elemento Descri\u00e7\u00e3o Exemplo N\u00e3o Terminais Representam elementos abstratos definidos por outras regras. <expression> , <term> Terminais S\u00e3o os s\u00edmbolos literais da linguagem. \"+\" , \"(\" , \"9\" Produ\u00e7\u00f5es Relacionam n\u00e3o terminais a uma ou mais express\u00f5es. <expression> ::= <term> \"+\" <term> Alternativas Usadas para descrever v\u00e1rias op\u00e7\u00f5es para a mesma regra, separadas por | . <number> ::= \"0\" | \"1\" Recurs\u00e3o Permite que uma regra referencie a si mesma, criando estruturas aninhadas. <expression> ::= <expression> \"+\" <term> Leitura de uma Gram\u00e1tica BNF Para o exemplo: <expression> ::= <term> \"+\" <term> | <term> <term> ::= <factor> \"*\" <factor> | <factor> <factor> ::= <number> <number> ::= \"0\" | \"1\" | \"2\" <expression> pode ser: Um <term> seguido de + e outro <term> . Ou simplesmente um <term> . <term> pode ser: Um <factor> multiplicado por outro <factor> . Ou apenas um <factor> . <factor> \u00e9 sempre um <number> . <number> pode ser \"0\" , \"1\" ou \"2\" . Exemplo v\u00e1lido : 1 + 2 * 0 Vantagens do BNF Clareza : Define a linguagem de forma rigorosa e leg\u00edvel. Simplicidade : Minimalista, sem muitos s\u00edmbolos adicionais. Recurs\u00e3o : Facilita a defini\u00e7\u00e3o de estruturas aninhadas, como express\u00f5es matem\u00e1ticas e blocos de c\u00f3digo. Limita\u00e7\u00f5es do BNF Expressividade Limitada : Dif\u00edcil lidar com detalhes opcionais ou repeti\u00e7\u00f5es sem tornar a gram\u00e1tica complexa. Falta de Recursos Avan\u00e7ados : N\u00e3o suporta elementos como express\u00f5es regulares diretamente. Ferramentas para Trabalhar com BNF ANTLR : Aceita varia\u00e7\u00f5es do BNF (como EBNF) e gera analisadores l\u00e9xicos e sint\u00e1ticos. https://www.antlr.org/ Railroad Diagram Generators : Geram diagramas visuais a partir da gram\u00e1tica BNF. https://bottlecaps.de/rr/ PLY (Python Lex-Yacc) : Permite implementar a gram\u00e1tica em Python. Se precisar de mais informa\u00e7\u00f5es ou exemplos, \u00e9 s\u00f3 perguntar! \ud83d\ude0a","title":"BNF"},{"location":"BNF/#bnf","text":"O Backus-Naur Form (BNF) \u00e9 um padr\u00e3o usado para descrever a gram\u00e1tica de linguagens de programa\u00e7\u00e3o e outras linguagens formais. Ele define a estrutura da linguagem de forma precisa e rigorosa, sendo amplamente utilizado em compiladores, interpretadores e documenta\u00e7\u00e3o t\u00e9cnica.","title":"BNF"},{"location":"BNF/#estrutura-basica-do-bnf","text":"O BNF utiliza produ\u00e7\u00f5es para descrever regras. Cada produ\u00e7\u00e3o \u00e9 composta por: N\u00e3o Terminais : Elementos abstratos da linguagem que precisam ser definidos por outras regras. Representados entre <> (ex.: <expression> , <term> ). Terminais : Elementos literais da linguagem, como palavras-chave, n\u00fameros e operadores. Geralmente escritos como est\u00e3o. Produ\u00e7\u00f5es : Cada regra tem o formato: bnf <n\u00e3o-terminal> ::= <express\u00e3o> Usa | para indicar alternativas. Recurs\u00e3o : Permite definir estruturas aninhadas.","title":"Estrutura B\u00e1sica do BNF"},{"location":"BNF/#exemplo-de-gramatica-em-bnf","text":"Vamos criar a gram\u00e1tica de uma calculadora simples: <expression> ::= <term> \"+\" <term> | <term> \"-\" <term> | <term> <term> ::= <factor> \"*\" <factor> | <factor> \"/\" <factor> | <factor> <factor> ::= <number> | \"(\" <expression> \")\" <number> ::= \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\"","title":"Exemplo de Gram\u00e1tica em BNF"},{"location":"BNF/#elementos-do-bnf","text":"Elemento Descri\u00e7\u00e3o Exemplo N\u00e3o Terminais Representam elementos abstratos definidos por outras regras. <expression> , <term> Terminais S\u00e3o os s\u00edmbolos literais da linguagem. \"+\" , \"(\" , \"9\" Produ\u00e7\u00f5es Relacionam n\u00e3o terminais a uma ou mais express\u00f5es. <expression> ::= <term> \"+\" <term> Alternativas Usadas para descrever v\u00e1rias op\u00e7\u00f5es para a mesma regra, separadas por | . <number> ::= \"0\" | \"1\" Recurs\u00e3o Permite que uma regra referencie a si mesma, criando estruturas aninhadas. <expression> ::= <expression> \"+\" <term>","title":"Elementos do BNF"},{"location":"BNF/#leitura-de-uma-gramatica-bnf","text":"Para o exemplo: <expression> ::= <term> \"+\" <term> | <term> <term> ::= <factor> \"*\" <factor> | <factor> <factor> ::= <number> <number> ::= \"0\" | \"1\" | \"2\" <expression> pode ser: Um <term> seguido de + e outro <term> . Ou simplesmente um <term> . <term> pode ser: Um <factor> multiplicado por outro <factor> . Ou apenas um <factor> . <factor> \u00e9 sempre um <number> . <number> pode ser \"0\" , \"1\" ou \"2\" . Exemplo v\u00e1lido : 1 + 2 * 0","title":"Leitura de uma Gram\u00e1tica BNF"},{"location":"BNF/#vantagens-do-bnf","text":"Clareza : Define a linguagem de forma rigorosa e leg\u00edvel. Simplicidade : Minimalista, sem muitos s\u00edmbolos adicionais. Recurs\u00e3o : Facilita a defini\u00e7\u00e3o de estruturas aninhadas, como express\u00f5es matem\u00e1ticas e blocos de c\u00f3digo.","title":"Vantagens do BNF"},{"location":"BNF/#limitacoes-do-bnf","text":"Expressividade Limitada : Dif\u00edcil lidar com detalhes opcionais ou repeti\u00e7\u00f5es sem tornar a gram\u00e1tica complexa. Falta de Recursos Avan\u00e7ados : N\u00e3o suporta elementos como express\u00f5es regulares diretamente.","title":"Limita\u00e7\u00f5es do BNF"},{"location":"BNF/#ferramentas-para-trabalhar-com-bnf","text":"ANTLR : Aceita varia\u00e7\u00f5es do BNF (como EBNF) e gera analisadores l\u00e9xicos e sint\u00e1ticos. https://www.antlr.org/ Railroad Diagram Generators : Geram diagramas visuais a partir da gram\u00e1tica BNF. https://bottlecaps.de/rr/ PLY (Python Lex-Yacc) : Permite implementar a gram\u00e1tica em Python. Se precisar de mais informa\u00e7\u00f5es ou exemplos, \u00e9 s\u00f3 perguntar! \ud83d\ude0a","title":"Ferramentas para Trabalhar com BNF"},{"location":"fluxo/","text":"Compilador/Interpretador Um compilador ou interpretador transforma o c\u00f3digo-fonte em uma forma execut\u00e1vel ou compreens\u00edvel pelo computador. Este processo \u00e9 dividido em v\u00e1rias etapas bem definidas. 1. Entrada do C\u00f3digo-Fonte O compilador ou interpretador recebe o c\u00f3digo-fonte como uma string, geralmente escrito em uma linguagem de alto n\u00edvel, como Python, C ou Java. 2. An\u00e1lise L\u00e9xica (Lexical Analysis) Objetivo : Quebrar o c\u00f3digo-fonte em unidades menores chamadas tokens . Funcionamento : - O c\u00f3digo \u00e9 processado caractere por caractere. - Tokens como palavras-chave ( if , while ), operadores ( + , - , = ), delimitadores ( ( , ) ), e identificadores (nomes de vari\u00e1veis) s\u00e3o reconhecidos. Sa\u00edda : Uma lista de tokens. Exemplo : Para o c\u00f3digo: x = 3 + 5 Tokens gerados: [IDENTIFIER(x), ASSIGN(=), NUMBER(3), PLUS(+), NUMBER(5)] 3. An\u00e1lise Sint\u00e1tica (Syntax Analysis) Objetivo : Garantir que a sequ\u00eancia de tokens segue as regras da gram\u00e1tica da linguagem. Funcionamento : - Os tokens s\u00e3o organizados em uma estrutura hier\u00e1rquica chamada \u00e1rvore de sintaxe ou parse tree . - Erros sint\u00e1ticos (ex.: esquecer um ponto e v\u00edrgula ou fechar um par\u00eantese) s\u00e3o detectados. Sa\u00edda : Uma \u00e1rvore de sintaxe (Parse Tree) . Exemplo : Para os tokens: [IDENTIFIER(x), ASSIGN(=), NUMBER(3), PLUS(+), NUMBER(5)] Parse Tree: Assign / \\ Name + | / \\ x 3 5 4. An\u00e1lise Sem\u00e2ntica (Semantic Analysis) Objetivo : Verificar se o c\u00f3digo faz sentido dentro do contexto da linguagem. Funcionamento : - Certifica-se de que as opera\u00e7\u00f5es s\u00e3o v\u00e1lidas (ex.: n\u00e3o \u00e9 permitido somar um n\u00famero com uma string). - Verifica o uso correto de vari\u00e1veis, tipos e fun\u00e7\u00f5es. Sa\u00edda : Uma \u00e1rvore de sintaxe anotada com informa\u00e7\u00f5es sem\u00e2nticas. Exemplo : x = \"hello\" + 3 # Erro sem\u00e2ntico: n\u00e3o pode somar string com n\u00famero. 5. Gera\u00e7\u00e3o da \u00c1rvore de Sintaxe Abstrata (AST) Objetivo : Transformar a Parse Tree em uma Abstract Syntax Tree (AST) , que \u00e9 uma forma mais simplificada e estruturada. Funcionamento : - Remove detalhes sint\u00e1ticos redundantes da Parse Tree. - Organiza os elementos essenciais em uma hierarquia. Sa\u00edda : Uma AST . Exemplo : Para o c\u00f3digo x = 3 + 5 , a AST seria: Assign / \\ Name + | / \\ x 3 5 6. Otimiza\u00e7\u00e3o (Opcional) Objetivo : Melhorar o desempenho do c\u00f3digo sem alterar seu comportamento. Funcionamento : - Remove c\u00f3digo desnecess\u00e1rio (ex.: x = 0; x = x + 1; \u2192 x = 1 ). - Simplifica express\u00f5es matem\u00e1ticas (ex.: 2 * 3 \u2192 6 ). Sa\u00edda : Uma vers\u00e3o otimizada da AST ou c\u00f3digo intermedi\u00e1rio. 7. Gera\u00e7\u00e3o de C\u00f3digo Intermedi\u00e1rio Objetivo : Traduzir a AST para uma representa\u00e7\u00e3o intermedi\u00e1ria (IR - Intermediate Representation), independente da linguagem ou da arquitetura. Sa\u00edda : C\u00f3digo intermedi\u00e1rio. Exemplo : LOAD 3 LOAD 5 ADD STORE x 8. Gera\u00e7\u00e3o de C\u00f3digo de M\u00e1quina Objetivo : Traduzir o c\u00f3digo intermedi\u00e1rio ou a AST diretamente em c\u00f3digo de m\u00e1quina execut\u00e1vel. Funcionamento : - A sa\u00edda depende do tipo de compilador: - Um compilador gera diretamente o c\u00f3digo de m\u00e1quina. - Um interpretador pode executar a AST ou o c\u00f3digo intermedi\u00e1rio diretamente. Sa\u00edda : C\u00f3digo execut\u00e1vel. Exemplo (em Assembly) : MOV R1, 3 MOV R2, 5 ADD R1, R2 MOV x, R1 9. Execu\u00e7\u00e3o Um compilador gera um programa execut\u00e1vel (ex.: .exe ) que pode ser executado posteriormente. Um interpretador executa o c\u00f3digo imediatamente, linha por linha ou diretamente da AST. Diferen\u00e7a entre Compilador e Interpretador Etapa Compilador Interpretador Sa\u00edda Final C\u00f3digo execut\u00e1vel (ex.: .exe ). Resultado imediato da execu\u00e7\u00e3o. Execu\u00e7\u00e3o do C\u00f3digo Ap\u00f3s a compila\u00e7\u00e3o completa. Durante a an\u00e1lise do c\u00f3digo. Velocidade da Execu\u00e7\u00e3o Geralmente mais r\u00e1pida. Geralmente mais lenta. Exemplo GCC para C, javac para Java. Python, Ruby, PHP.","title":"Compilador/Interpretador"},{"location":"fluxo/#compiladorinterpretador","text":"Um compilador ou interpretador transforma o c\u00f3digo-fonte em uma forma execut\u00e1vel ou compreens\u00edvel pelo computador. Este processo \u00e9 dividido em v\u00e1rias etapas bem definidas.","title":"Compilador/Interpretador"},{"location":"fluxo/#1-entrada-do-codigo-fonte","text":"O compilador ou interpretador recebe o c\u00f3digo-fonte como uma string, geralmente escrito em uma linguagem de alto n\u00edvel, como Python, C ou Java.","title":"1. Entrada do C\u00f3digo-Fonte"},{"location":"fluxo/#2-analise-lexica-lexical-analysis","text":"Objetivo : Quebrar o c\u00f3digo-fonte em unidades menores chamadas tokens . Funcionamento : - O c\u00f3digo \u00e9 processado caractere por caractere. - Tokens como palavras-chave ( if , while ), operadores ( + , - , = ), delimitadores ( ( , ) ), e identificadores (nomes de vari\u00e1veis) s\u00e3o reconhecidos. Sa\u00edda : Uma lista de tokens. Exemplo : Para o c\u00f3digo: x = 3 + 5 Tokens gerados: [IDENTIFIER(x), ASSIGN(=), NUMBER(3), PLUS(+), NUMBER(5)]","title":"2. An\u00e1lise L\u00e9xica (Lexical Analysis)"},{"location":"fluxo/#3-analise-sintatica-syntax-analysis","text":"Objetivo : Garantir que a sequ\u00eancia de tokens segue as regras da gram\u00e1tica da linguagem. Funcionamento : - Os tokens s\u00e3o organizados em uma estrutura hier\u00e1rquica chamada \u00e1rvore de sintaxe ou parse tree . - Erros sint\u00e1ticos (ex.: esquecer um ponto e v\u00edrgula ou fechar um par\u00eantese) s\u00e3o detectados. Sa\u00edda : Uma \u00e1rvore de sintaxe (Parse Tree) . Exemplo : Para os tokens: [IDENTIFIER(x), ASSIGN(=), NUMBER(3), PLUS(+), NUMBER(5)] Parse Tree: Assign / \\ Name + | / \\ x 3 5","title":"3. An\u00e1lise Sint\u00e1tica (Syntax Analysis)"},{"location":"fluxo/#4-analise-semantica-semantic-analysis","text":"Objetivo : Verificar se o c\u00f3digo faz sentido dentro do contexto da linguagem. Funcionamento : - Certifica-se de que as opera\u00e7\u00f5es s\u00e3o v\u00e1lidas (ex.: n\u00e3o \u00e9 permitido somar um n\u00famero com uma string). - Verifica o uso correto de vari\u00e1veis, tipos e fun\u00e7\u00f5es. Sa\u00edda : Uma \u00e1rvore de sintaxe anotada com informa\u00e7\u00f5es sem\u00e2nticas. Exemplo : x = \"hello\" + 3 # Erro sem\u00e2ntico: n\u00e3o pode somar string com n\u00famero.","title":"4. An\u00e1lise Sem\u00e2ntica (Semantic Analysis)"},{"location":"fluxo/#5-geracao-da-arvore-de-sintaxe-abstrata-ast","text":"Objetivo : Transformar a Parse Tree em uma Abstract Syntax Tree (AST) , que \u00e9 uma forma mais simplificada e estruturada. Funcionamento : - Remove detalhes sint\u00e1ticos redundantes da Parse Tree. - Organiza os elementos essenciais em uma hierarquia. Sa\u00edda : Uma AST . Exemplo : Para o c\u00f3digo x = 3 + 5 , a AST seria: Assign / \\ Name + | / \\ x 3 5","title":"5. Gera\u00e7\u00e3o da \u00c1rvore de Sintaxe Abstrata (AST)"},{"location":"fluxo/#6-otimizacao-opcional","text":"Objetivo : Melhorar o desempenho do c\u00f3digo sem alterar seu comportamento. Funcionamento : - Remove c\u00f3digo desnecess\u00e1rio (ex.: x = 0; x = x + 1; \u2192 x = 1 ). - Simplifica express\u00f5es matem\u00e1ticas (ex.: 2 * 3 \u2192 6 ). Sa\u00edda : Uma vers\u00e3o otimizada da AST ou c\u00f3digo intermedi\u00e1rio.","title":"6. Otimiza\u00e7\u00e3o (Opcional)"},{"location":"fluxo/#7-geracao-de-codigo-intermediario","text":"Objetivo : Traduzir a AST para uma representa\u00e7\u00e3o intermedi\u00e1ria (IR - Intermediate Representation), independente da linguagem ou da arquitetura. Sa\u00edda : C\u00f3digo intermedi\u00e1rio. Exemplo : LOAD 3 LOAD 5 ADD STORE x","title":"7. Gera\u00e7\u00e3o de C\u00f3digo Intermedi\u00e1rio"},{"location":"fluxo/#8-geracao-de-codigo-de-maquina","text":"Objetivo : Traduzir o c\u00f3digo intermedi\u00e1rio ou a AST diretamente em c\u00f3digo de m\u00e1quina execut\u00e1vel. Funcionamento : - A sa\u00edda depende do tipo de compilador: - Um compilador gera diretamente o c\u00f3digo de m\u00e1quina. - Um interpretador pode executar a AST ou o c\u00f3digo intermedi\u00e1rio diretamente. Sa\u00edda : C\u00f3digo execut\u00e1vel. Exemplo (em Assembly) : MOV R1, 3 MOV R2, 5 ADD R1, R2 MOV x, R1","title":"8. Gera\u00e7\u00e3o de C\u00f3digo de M\u00e1quina"},{"location":"fluxo/#9-execucao","text":"Um compilador gera um programa execut\u00e1vel (ex.: .exe ) que pode ser executado posteriormente. Um interpretador executa o c\u00f3digo imediatamente, linha por linha ou diretamente da AST.","title":"9. Execu\u00e7\u00e3o"},{"location":"fluxo/#diferenca-entre-compilador-e-interpretador","text":"Etapa Compilador Interpretador Sa\u00edda Final C\u00f3digo execut\u00e1vel (ex.: .exe ). Resultado imediato da execu\u00e7\u00e3o. Execu\u00e7\u00e3o do C\u00f3digo Ap\u00f3s a compila\u00e7\u00e3o completa. Durante a an\u00e1lise do c\u00f3digo. Velocidade da Execu\u00e7\u00e3o Geralmente mais r\u00e1pida. Geralmente mais lenta. Exemplo GCC para C, javac para Java. Python, Ruby, PHP.","title":"Diferen\u00e7a entre Compilador e Interpretador"},{"location":"help/","text":"Help For full documentation visit mkdocs.org . Commands mkdocs new . - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Help"},{"location":"help/#help","text":"For full documentation visit mkdocs.org .","title":"Help"},{"location":"help/#commands","text":"mkdocs new . - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"help/#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"ply/","text":"PLY O PLY (Python Lex-Yacc) usa express\u00f5es regulares para definir os padr\u00f5es que o Lexer deve reconhecer. As express\u00f5es regulares seguem o padr\u00e3o da biblioteca re do Python. Elementos das Express\u00f5es Regulares Elemento Descri\u00e7\u00e3o Exemplo Caractere Literal Reconhece um caractere literal espec\u00edfico. a reconhece apenas a . Conjuntos Usa colchetes [] para corresponder a um conjunto de caracteres. [a-z] corresponde a letras min\u00fasculas de a a z . Quantificadores Define quantas vezes um padr\u00e3o deve aparecer. a+ corresponde a a , aa , etc. Altern\u00e2ncia Usa | para corresponder a uma ou outra alternativa. a|b corresponde a a ou b . Agrupamento Usa par\u00eanteses para agrupar partes de uma express\u00e3o regular. (ab)+ corresponde a ab , abab , etc. Meta-caracteres Caracteres especiais que t\u00eam significados espec\u00edficos em express\u00f5es regulares. \\d para d\u00edgitos, \\w para caracteres alfanum\u00e9ricos. Escapando Usa \\ para tratar meta-caracteres como literais. \\+ corresponde ao caractere + . \u00c2ncoras Define posi\u00e7\u00f5es na string, como in\u00edcio ou fim. ^abc$ corresponde exatamente a abc . Recursos Comuns do PLY Caractere Literal t_PLUS = r'\\+' Corresponde apenas ao caractere + . Grupos t_IF_OR_ELSE = r'if|else' Corresponde \u00e0 palavra if ou else . Quantificadores S\u00edmbolo Descri\u00e7\u00e3o * Zero ou mais vezes. + Uma ou mais vezes. ? Zero ou uma vez. {n} Exatamente n vezes. {n,m} De n at\u00e9 m vezes. Exemplo: t_NUMBER = r'\\d+(\\.\\d+)?' Corresponde a n\u00fameros inteiros ( 123 ) ou decimais ( 123.45 ). Conjuntos de Caracteres t_LETTER = r'[a-zA-Z]' Corresponde a qualquer letra mai\u00fascula ou min\u00fascula. t_DIGIT = r'[0-9]' Corresponde a qualquer d\u00edgito. Escapando t_LPAREN = r'\\(' t_RPAREN = r'\\)' Corresponde a ( e ) . \u00c2ncoras \u00c2ncora Descri\u00e7\u00e3o ^ In\u00edcio da string. $ Fim da string. Exemplo: r'^[A-Za-z_][A-Za-z0-9_]*$' Corresponde a identificadores v\u00e1lidos que devem estar sozinhos na entrada. Meta-caracteres Comuns Meta-caractere Descri\u00e7\u00e3o Exemplo . Qualquer caractere, exceto nova linha. a.b \u2192 acb , axb . \\d D\u00edgitos (0-9). \\d+ \u2192 123 , 4567 . \\w Letras, n\u00fameros ou _ . \\w+ \u2192 abc123 , x_y . \\s Espa\u00e7os em branco. \\s+ \u2192 , \\t . \\b Limite de palavra. \\bword\\b . Regras do PLY Definir Tokens como Fun\u00e7\u00f5es ou Vari\u00e1veis Fun\u00e7\u00f5es s\u00e3o \u00fateis para adicionar comportamento, como convers\u00e3o de valores: def t_NUMBER(t): r'\\d+(\\.\\d+)?' t.value = float(t.value) # Converte o n\u00famero para float return t Vari\u00e1veis s\u00e3o suficientes para padr\u00f5es simples: t_PLUS = r'\\+' Ordem Importa O Lexer aplica as regras na ordem em que elas s\u00e3o definidas . Coloque regras mais espec\u00edficas antes das gerais. example import ply.lex as lex import ply.yacc as yacc # === LEXER ================================================= tokens = ( 'NUMBER', 'PLUS', 'MINUS', 'TIMES', 'DIVIDE', 'LPAREN', 'RPAREN', ) # Regras de express\u00e3o regular para tokens simples t_PLUS = r'\\+' t_MINUS = r'-' t_TIMES = r'\\*' t_DIVIDE = r'/' t_LPAREN = r'\\(' t_RPAREN = r'\\)' # Ignorar espa\u00e7os e tabula\u00e7\u00f5es t_ignore = ' \\t' def t_NUMBER(t): r'\\d+(\\.\\d+)?' t.value = float(t.value) return t # Regra para rastrear erros l\u00e9xicos def t_error(t): print(f\"Caractere inv\u00e1lido: {t.value[0]}\") t.lexer.skip(1) # Constru\u00e7\u00e3o do lexer lexer = lex.lex() # === PARSER ================================================= # Preced\u00eancia dos operadores precedence = ( ('left', 'PLUS', 'MINUS'), ('left', 'TIMES', 'DIVIDE'), ) # Regras da gram\u00e1tica def p_expression_binop(p): '''expression : expression PLUS expression | expression MINUS expression | expression TIMES expression | expression DIVIDE expression''' if p[2] == '+': p[0] = p[1] + p[3] elif p[2] == '-': p[0] = p[1] - p[3] elif p[2] == '*': p[0] = p[1] * p[3] elif p[2] == '/': p[0] = p[1] / p[3] def p_expression_group(p): 'expression : LPAREN expression RPAREN' p[0] = p[2] def p_expression_number(p): 'expression : NUMBER' p[0] = p[1] def p_error(p): print(\"Erro de sintaxe!\") # Constru\u00e7\u00e3o do parser parser = yacc.yacc() # === TESTE ================================================================= def main(): while True: try: s = input(\"Digite a express\u00e3o: \") except EOFError: break if not s: continue result = parser.parse(s) print(f\"Resultado: {result}\") if __name__ == '__main__': main()","title":"PLY"},{"location":"ply/#ply","text":"O PLY (Python Lex-Yacc) usa express\u00f5es regulares para definir os padr\u00f5es que o Lexer deve reconhecer. As express\u00f5es regulares seguem o padr\u00e3o da biblioteca re do Python.","title":"PLY"},{"location":"ply/#elementos-das-expressoes-regulares","text":"Elemento Descri\u00e7\u00e3o Exemplo Caractere Literal Reconhece um caractere literal espec\u00edfico. a reconhece apenas a . Conjuntos Usa colchetes [] para corresponder a um conjunto de caracteres. [a-z] corresponde a letras min\u00fasculas de a a z . Quantificadores Define quantas vezes um padr\u00e3o deve aparecer. a+ corresponde a a , aa , etc. Altern\u00e2ncia Usa | para corresponder a uma ou outra alternativa. a|b corresponde a a ou b . Agrupamento Usa par\u00eanteses para agrupar partes de uma express\u00e3o regular. (ab)+ corresponde a ab , abab , etc. Meta-caracteres Caracteres especiais que t\u00eam significados espec\u00edficos em express\u00f5es regulares. \\d para d\u00edgitos, \\w para caracteres alfanum\u00e9ricos. Escapando Usa \\ para tratar meta-caracteres como literais. \\+ corresponde ao caractere + . \u00c2ncoras Define posi\u00e7\u00f5es na string, como in\u00edcio ou fim. ^abc$ corresponde exatamente a abc .","title":"Elementos das Express\u00f5es Regulares"},{"location":"ply/#recursos-comuns-do-ply","text":"","title":"Recursos Comuns do PLY"},{"location":"ply/#caractere-literal","text":"t_PLUS = r'\\+' Corresponde apenas ao caractere + .","title":"Caractere Literal"},{"location":"ply/#grupos","text":"t_IF_OR_ELSE = r'if|else' Corresponde \u00e0 palavra if ou else .","title":"Grupos"},{"location":"ply/#quantificadores","text":"S\u00edmbolo Descri\u00e7\u00e3o * Zero ou mais vezes. + Uma ou mais vezes. ? Zero ou uma vez. {n} Exatamente n vezes. {n,m} De n at\u00e9 m vezes. Exemplo: t_NUMBER = r'\\d+(\\.\\d+)?' Corresponde a n\u00fameros inteiros ( 123 ) ou decimais ( 123.45 ).","title":"Quantificadores"},{"location":"ply/#conjuntos-de-caracteres","text":"t_LETTER = r'[a-zA-Z]' Corresponde a qualquer letra mai\u00fascula ou min\u00fascula. t_DIGIT = r'[0-9]' Corresponde a qualquer d\u00edgito.","title":"Conjuntos de Caracteres"},{"location":"ply/#escapando","text":"t_LPAREN = r'\\(' t_RPAREN = r'\\)' Corresponde a ( e ) .","title":"Escapando"},{"location":"ply/#ancoras","text":"\u00c2ncora Descri\u00e7\u00e3o ^ In\u00edcio da string. $ Fim da string. Exemplo: r'^[A-Za-z_][A-Za-z0-9_]*$' Corresponde a identificadores v\u00e1lidos que devem estar sozinhos na entrada.","title":"\u00c2ncoras"},{"location":"ply/#meta-caracteres-comuns","text":"Meta-caractere Descri\u00e7\u00e3o Exemplo . Qualquer caractere, exceto nova linha. a.b \u2192 acb , axb . \\d D\u00edgitos (0-9). \\d+ \u2192 123 , 4567 . \\w Letras, n\u00fameros ou _ . \\w+ \u2192 abc123 , x_y . \\s Espa\u00e7os em branco. \\s+ \u2192 , \\t . \\b Limite de palavra. \\bword\\b .","title":"Meta-caracteres Comuns"},{"location":"ply/#regras-do-ply","text":"","title":"Regras do PLY"},{"location":"ply/#definir-tokens-como-funcoes-ou-variaveis","text":"Fun\u00e7\u00f5es s\u00e3o \u00fateis para adicionar comportamento, como convers\u00e3o de valores: def t_NUMBER(t): r'\\d+(\\.\\d+)?' t.value = float(t.value) # Converte o n\u00famero para float return t Vari\u00e1veis s\u00e3o suficientes para padr\u00f5es simples: t_PLUS = r'\\+'","title":"Definir Tokens como Fun\u00e7\u00f5es ou Vari\u00e1veis"},{"location":"ply/#ordem-importa","text":"O Lexer aplica as regras na ordem em que elas s\u00e3o definidas . Coloque regras mais espec\u00edficas antes das gerais.","title":"Ordem Importa"},{"location":"ply/#example","text":"import ply.lex as lex import ply.yacc as yacc # === LEXER ================================================= tokens = ( 'NUMBER', 'PLUS', 'MINUS', 'TIMES', 'DIVIDE', 'LPAREN', 'RPAREN', ) # Regras de express\u00e3o regular para tokens simples t_PLUS = r'\\+' t_MINUS = r'-' t_TIMES = r'\\*' t_DIVIDE = r'/' t_LPAREN = r'\\(' t_RPAREN = r'\\)' # Ignorar espa\u00e7os e tabula\u00e7\u00f5es t_ignore = ' \\t' def t_NUMBER(t): r'\\d+(\\.\\d+)?' t.value = float(t.value) return t # Regra para rastrear erros l\u00e9xicos def t_error(t): print(f\"Caractere inv\u00e1lido: {t.value[0]}\") t.lexer.skip(1) # Constru\u00e7\u00e3o do lexer lexer = lex.lex() # === PARSER ================================================= # Preced\u00eancia dos operadores precedence = ( ('left', 'PLUS', 'MINUS'), ('left', 'TIMES', 'DIVIDE'), ) # Regras da gram\u00e1tica def p_expression_binop(p): '''expression : expression PLUS expression | expression MINUS expression | expression TIMES expression | expression DIVIDE expression''' if p[2] == '+': p[0] = p[1] + p[3] elif p[2] == '-': p[0] = p[1] - p[3] elif p[2] == '*': p[0] = p[1] * p[3] elif p[2] == '/': p[0] = p[1] / p[3] def p_expression_group(p): 'expression : LPAREN expression RPAREN' p[0] = p[2] def p_expression_number(p): 'expression : NUMBER' p[0] = p[1] def p_error(p): print(\"Erro de sintaxe!\") # Constru\u00e7\u00e3o do parser parser = yacc.yacc() # === TESTE ================================================================= def main(): while True: try: s = input(\"Digite a express\u00e3o: \") except EOFError: break if not s: continue result = parser.parse(s) print(f\"Resultado: {result}\") if __name__ == '__main__': main()","title":"example"}]}